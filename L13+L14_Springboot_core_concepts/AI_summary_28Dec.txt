Quick recap

The meeting focused on explaining core Spring Boot concepts, specifically Inversion of Control (IOC) and Dependency Injection. The instructor demonstrated how Spring Boot creates and manages beans through its IOC container, explaining the difference between component and bean annotations and when each should be used. They covered various injection methods, including constructor injection, field injection, and setter injection, while highlighting the advantages and limitations of each approach. The discussion included practical examples showing how beans are created during application startup and how dependencies can be injected into classes. The instructor also explained the concept of bean scopes, including singleton and prototype, and how Spring Boot handles different types of configurations. The session concluded with guidance for students to review the material and practice with additional resources, including the official Spring IO website and documentation.

Next steps

- All students: Review the recording of this class to ensure IOC  and Dependency Injection concepts are crystal clear before next Saturday's class
- All students: Practice the concepts covered  by themselves during the weekdays
- All students: Read through articles on spring.io website, specifically the Core Technologies section covering IOC Container, Dependency Injection, and Beans Overview
- All students: Use ChatGPT or other Gen AI tools to help filter out relevant topics to study from the spring.io documentation

Summary

Spring Boot IoC and Dependency Injection
The instructor explained the concepts of Inversion of Control (IoC) and Dependency Injection in Spring Boot. They discussed how Spring Boot creates objects for classes annotated with @Component, and demonstrated this by adding logging statements to a sample application. The instructor also explained the terms "bean," "singleton," "shared instance," and how Spring Boot manages the lifecycle of these objects. They concluded by showing that classes without the @Component annotation do not have objects created by Spring Boot, unless explicitly annotated.


Spring Boot IOC Container Overview
The discussion explained how Spring Boot creates objects, known as beans, and stores them in an IOC container before application startup. The IOC container resides in main memory, similar to normal Java objects, and is crucial for understanding dependency injection and troubleshooting errors. Bean names are derived from class names, but can be customized using the @Qualifier annotation. The explanation included a demonstration of how to find bean names by searching for class names in application logs.


Spring Boot Bean Annotations Explained
The discussion focused on Spring Boot annotations, particularly the differences between component and bean annotations. Aditya explained that component is a class-level annotation used to denote that a class should have a bean created during application startup, while bean is a method-level annotation used to define a specific function that returns a particular type of object. He demonstrated how to create a bean for an external library class like ObjectMapper by defining a configuration class with a method that returns an instance of the class, annotated with @Bean. The discussion concluded with an explanation of how Spring Boot stores beans in an IOC container as a map with bean names and types, and how changing method names affects the bean names.


Spring vs Spring Boot Bean Configuration
The discussion clarified the differences between Spring and Spring Boot frameworks, particularly regarding bean configuration. Spring requires explicit XML-based bean definitions, while Spring Boot uses annotations like @Bean and @Component to automatically manage beans without the need for XML configuration. The conversation also addressed that beans are not necessarily created during application startup, as beans with non_singleton scopes are instantiated on demand when required by other classes.


Spring Boot IOC Best Practices
The discussion focused on when to use Spring Boot's IOC (Inversion of Control) feature for creating objects. GeeksforGeeks explained that beans should not be used for model entities representing real-world objects, as these should be created manually by developers. Instead, beans should be used for controller, service, and repository classes that can be reused throughout the application. The instructor demonstrated how to optimize object creation by using constructor injection and explained that Spring Boot can automatically manage object creation and reuse to improve application performance.


Spring Boot Dependency Injection Explained
The discussion focused on understanding Spring Boot's object creation and dependency injection mechanisms. GeeksforGeeks explained the concept of inversion of control, where Spring Boot creates objects, and demonstrated how dependency injection allows these objects to be reused through auto-wiring. They showed that when a bean is not defined, the application fails to start with a clear error message, and explained how to debug and troubleshoot such issues. The conversation concluded with an explanation of how Spring Boot calls the default constructor during object creation.


Spring Boot Constructor Injection Explained
The discussion focused on Spring Boot's constructor selection process, where it was explained that Spring Boot uses the default constructor when no parameter values are defined, but will use a parameterized constructor if the values are known. The team explored how Spring Boot creates and injects beans, with a detailed explanation that beans are not limited to objects but can also include configurations like strings. They demonstrated that the same object is used across API calls within a running application, eliminating the need for manual object creation. The session concluded with an explanation of how application objects are stored in volatile memory and are recreated with each application restart, with Abhinay clarifying that new objects are created for each request while the application is running.


Spring Boot Application Concepts
The discussion focused on Java and Spring Boot concepts, including default constructors, auto-wiring, and the flow of an application. Mohammed and GeeksforGeeks clarified that Spring Boot uses default constructors if not defined by the user, allowing for auto-wiring and system.out.println statements. They explained the auto-wiring process and the importance of initializing objects to avoid null pointer exceptions. Anuradha asked about handling batch operations in a Spring Boot application, and GeeksforGeeks introduced the concept of command line runners, explaining how they can be used to execute operations during application startup without relying on API calls.


Spring Boot Auto-Wiring Explained
The discussion focused on Spring Boot's auto-wiring functionality, particularly how it works with static and non-static fields. It was explained that auto-wiring does not work with static fields because static variables are defined at the class level, not the object level. The group also explored different ways of auto-wiring, including parameter injection, field-level injection, and constructor injection, with the conclusion that the @Autowired annotation is mandatory only when there are multiple constructors in a class. The session concluded with an explanation of how Spring Boot resolves constructor dilemmas by matching bean types, and how to read and understand bean creation exception messages.


Spring Boot Dependency Injection Explained
The instructor explained different types of dependency injection in Spring Boot, including constructor injection, field injection, and setter injection. They discussed the pros and cons of each approach, with constructor injection being preferred for its explicit initialization and field injection being useful when fields are not used within the constructor. The instructor also mentioned that setter injection is not commonly used due to its manual invocation requirement. The session concluded with an announcement that the next class would cover topics such as component scanning, boilerplate annotations, and bean definitions, with a focus on ensuring a clear understanding of inversion of control and dependency injection before proceeding.